{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ALU project in Digital Logic Sim","text":"<p>My project is to make an ALU in Digital Logic Sim<sup>1</sup>. By doing this project I will learn how does computer work. After doing that i will extend the project until I have a fully functional computer in the Simulation. And all of this project started with only an NAND gate. If you want to see my progress, all the chips i used are in the scr folder.</p>"},{"location":"#introduction","title":"Introduction","text":"<p>This project is my first GitHub repository, i do this to learn how to do a github repository and how does computer work, if you want to learn how does computer work I recomand this series by Sebastian Lague, the simulation that i am using for this is from him. You can see the progression of the project with the picture below and the upcoming feature with the road map.</p> <p></p>"},{"location":"#roadmap","title":"Roadmap","text":""},{"location":"#basic-alu","title":"Basic ALU","text":"<ul> <li> Making the logics gates</li> <li> Creating a basic 1-bit adder</li> <li> Creating a 7 to 8-bit adder</li> <li> Making the adder be able to andle negative number with a new bit</li> <li> Creating a one-bit storage</li> <li> Transforming it into a 256 octets memory</li> <li> Creating an ALU chip that can use an adress to do an action using the 256 octets memory</li> </ul>"},{"location":"#visual","title":"Visual","text":"<ul> <li> Making a circuit which can take a 4-bit number (capped at 9) and transforming it in 8 bits that can be taken by 7 segment display</li> <li> Making it be able to show negative (and change color)</li> <li> Making the display be connectible and removing the extra zero (on toggle)</li> <li> Making the display move the negative sign (-)</li> <li> Isolating the hundreds out of a 8-bit number</li> <li> Isolating the tens out of a 8-bit number</li> <li> Isolating the ones out of a 8-bit number</li> </ul>"},{"location":"#what-is-digital-logic-sim","title":"What is Digital Logic Sim ?","text":"<p>Digital logic Sim is a minimalistic digital logic simulator. You can create various chips starting with a NAND gate, from there you can go the whole way to a little computer ! This sim is made by Sebestian Lague.</p> <ol> <li> <p>Digital logic sim is made by Sebastian Lague. You can find his project here and his channel here.\u00a0\u21a9</p> </li> </ol>"},{"location":"introduction/FAQ/","title":"FAQ","text":""},{"location":"introduction/FAQ/#how-to-install-the-chips-in-digital-logic-sim","title":"How to install the chips in Digital Logic Sim ?","text":"<ol> <li> <p>Go to C:\\Users\\Your name\\AppData\\LocalLow\\SebastianLague\\Digital-Logic-Sim\\Projects\\Project Name\\Chips</p> </li> <li> <p>Copy and paste all the chips or un-zip the zipped version (comming soon)</p> <ul> <li>If you used the zip version make sure to put the chips in the Chips folder and delete the zip folder if it's in the Chips folder</li> </ul> </li> </ol> <p>And you are done !</p>"},{"location":"introduction/FAQ/#where-do-i-install-digital-logic-sim","title":"Where do I install Digital Logic Sim ?","text":"<p>You can get Digital Logic Sim here.</p>"},{"location":"introduction/chips/","title":"Table of the chips","text":"<p>A table that describe the chips.</p> <p>\u26a0 This table only contains the major chips \u26a0</p> Chip name Description Input Output 0 to 9 Detector A group of chips that can detect the number they are assign to. Output a 8-bit code that a 7 display segment can read 1x 4-bit 1x 8-bit 10 entry 8-bit OR 10 8-bit OR grouped together 10x 8-bit 1x 8-bit 16 9-bit Memory A memory that as 16x9-bit of memory 2x 8-bit, 5x 1-bit 1x 8-bit, 1x 1-bit 259 9-bit Memory A memory that as 256x9-bit of memory 3x 8-bit, x3 1-bit 1x 8-bit, 1x 1-bit 4 AND 4 AND logic gate put together 4x 1-bit 1x 1-bit 7 to 8 bit adder A binary adder that takes 2 7-bit number and adds them together outputing a 8-bit number 2x 8-bit (The last bit is not used) 1x 8-bit, 8x 1-bit 7 to 8 bit signed adder The same as the 7 to 8 bit adder but as another bit for each number telling if it is negative or not. 2x 8-bit (The last bit is not used), 2x 1-bit 1x 8-bit, 9x 1-bit 8 -bit OR An OR logic gate that takes 8-bit input 2x 8-bit 1x 8-bit 9-bit register A register that stores a 8-bit number and one more bit (generaly for the negative numbers) 1x 8-bit, 5x 1-bit 1x 8-bit, 1x 1-bit AND A basic AND logic gate 2x 1-bit 1x 1-bit Comparateur 1-bit A chip that takes 2 bit and say if they are equal or if one is grater than the other 2x 1-bit 3x 1-bit Comparateur 8-bit A chip that takes 2 8-bit number and say if they are equal or if one is grater than the other 2x 8-bit 3x 1-bit D Latch A data latch that can store 1 bit 2x 1-bit 1x 1-bit XOR A basic XOR logic gate 2x 1-bit 1x 1-bit OR A basic OR logic gate 2x 1-bit 1x 1-bit NOT A basic NOT logic gate 1x 1-bit 1x 1-bit NAND A basic NAND logic gate 2x 1-bit 1x 1-bit NOR A basic NOR logic gate 2x 1-bit 1x 1-bit Number display Get 3 digits to display on the 7 segment display, can also display a minus sign and get rid of extras zero 3x 4-bit, 2x 1-bit None Number detector A chip that get a 4-bit number and transform it into a 8-bit format that a 7 segment display can understand. It can also hide the zeros 1x 4-bit, 1x 1-bit 1x 8-bit, 1x 1-bit Inverseur 8-bit A chip that invert a 8-bit signal if the 1-bit entry is active 1x 8-bit, 1x 1-bit 1x 8-bit Stopper Stops the current of a 1-bit signal if another 1-bit signal is active 2x 1-bit 1x 1-bit Stopper 8-bit Does the same as a stopper but for a 8-bit entry 1x 8-bit, 1x 1-bit 1x 8-bit DECODER 2-4 Get 2 1-bit input and uses  it to turn one of it's output 2x 1-bit 4x 1-bit 8-BIT 3 state buffer A 3 state bufferfor 8-bit number 1x 8-bit, 1x 1-bit 1x 8-bit DABBLE A chip used in the Doubble Dabble Algorithm 4x 1-bit 4x 1-bit Number decompositor A chip that execute the Doubble Dabble Algorithm to decompose an 8-bit number into 3 4-bit number (Hundreds, Tens, Ones) 1x 8-bit 3x 4-bit"},{"location":"introduction/chips/#an-image-of-all-the-chips","title":"An image of all the chips","text":""},{"location":"introduction/logic_gates/","title":"The Logic gates","text":"<p>The logic gates are the core of all the computers. If there are no logic gates, there are no computers. The logic gates  take one or two input and as one input. They behavior can be listed in a table of truth. Here is the list of all the logic gates :</p> <ul> <li>NAND</li> <li>NOT</li> <li>AND</li> <li>OR</li> <li>NOR</li> <li>XOR</li> <li>XNOR</li> </ul> <p>But NAND is special, because he makes all the other logic gates. Here is it's table of truth</p> A B A NAND B 0 0 1 1 0 1 0 1 1 1 1 0 <p>Now, what is the next logic gate ? And how can we make it with a NAND ? Well the next gate is the NOT gate. His truth table is the following :</p> A NOT 0 1 1 0 <p>As you can see, it only has 1 input, and it invert it, how do we build this gate with an NAND gate ?</p> <p>The N in NAND stand for NOT, the following gates with an N also means NOT, it is just an inverted version of the other gate. Now that we know that, we can build it with a NAND gate by connecting the 2 input of a NAND gate with only 1 input. Like this :</p> <p></p> <p>We can see that in the truth table, when the 2 input are 0, the output is 1 and if the 2 input are 1, the output is 0. This mean that if A is a 0, the output will be a 1, and if A is a 1, the output will be a 0, following our truth table !</p> <p>Now with these 2 gates, we can build an AND gate which as the following truth table :</p> A B A AND B 0 0 0 1 0 0 0 1 0 1 1 1 <p>This gate only output a 1 if both A and B is a 1. To creating this gate is simple. You may noticed that the AND gate is an inverted NAND gate. To invert we only have to use a NOT like this :</p> <p></p> <p>The next gate is an OR gate. An OR gate output a 1 if one or both is input are a 1. Like this :</p> A B A OR B 0 0 0 1 0 1 0 1 1 1 1 1 <p>To do this gate, we will use a law, De Morgan's laws.</p> <p>This law can be expressed in English as:</p> <ul> <li>The negation of \"A AND B\" is the same as \"NOT A OR NOT B\".</li> <li>The negation of \"A OR B\" is the same as \"NOT A AND NOT B\".</li> </ul> <p>So to get an OR we need 3 NOT and 1 AND gate. It's build like that :</p> <p></p> <p>Now, we are going to build the NOR gate. This gate is an inverted OR gate.</p> A B A NOR B 0 0 1 1 0 0 0 1 0 1 1 0 <p>Like we did previously, we will just use a NOT gate like this :</p> <p></p> <p>The XOR gate is a complicated gate. It takes 2 input, and output a 1 if ONLY 1 of the input is a 1. If both are ones,  he output a 0.</p> A B A XOR B 0 0 0 1 0 1 0 1 1 1 1 0 <p>To do that we will only use 3 gates. An OR gate to detect if or both of the input are 1. An NAND gate to turn off when both of the input are 1. And finally an AND gate to join them. Both input goes in the OR and the NAND gate, then the  output of the 2 gates goes in the AND gate. When wired up in the simulation, it should look like this :</p> <p></p> <p>Finally, the XNOR gate, like all the gates with a N, all we have to do is add a not at the end. Because the output are  just inverted in the truth table that you can see below.</p> A B A XNOR B 0 0 1 1 0 0 0 1 0 1 1 1 <p></p>"}]}